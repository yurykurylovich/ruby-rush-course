# Все методы в отдельном файле viselitsa_methods, который вставляем
# в самом начале программы вызовом метода require_relatove.
#
# Обратите внимание, что мы используем для этого не require, а require_relative.
#
# В отличие от require этот метод ищет файлы .rb (расширение можно не указывать)
# в той же папке, где лежит сама программа, а не в той папке, откуда мы
# запускаем программу. Удобно!
require_relative 'hangman_methods'

# очистить экран, чтобы не видно было загаданное слово
cls

puts "Игра виселица."
sleep 1

# Создадим массив букв загаданного слова.
# метод get_letters будет возвращать массив из букв загаданного слова.
letters = get_letters

# Переменная errors, будет хранить текущее значение количества
# ошибок, которое совершил пользователь. Начальное значение, очевидно, 0.
errors = 0

# Объявление массивов (для правильно отгаданных букв и для букв, которых нет в
# загаданном слове). Каждая попытка пользователя будет попадать в один из этих
# массивов.
good_letters = []
bad_letters = []

# Основной цикл программы, в котором спрашиваем у пользователя букву и обновляем
# все переменные в зависимости от его ответа. У пользователя есть 7
# осечек, чтобы успеть отгадать слово. Поэтому игра продолжается, пока
# количество ошибок меньше 7.
while errors < 7
  # Выводим текущий статус игры и, если есть, открытые буквы с помощью метода
  # print_status, который принимает на вход все переменные, нужные для описания
  # состояния игры: буквы слова, отгаданные буквы, промахи и количество ошибок.
  print_status(letters, good_letters, bad_letters, errors)

  # Просим пользователя ввести следующую букву, всю обработку его ввода будет
  # для нас делать метод get_user_input, который вернет нам только букву.
  puts "\nВведите следующую букву"
  user_input = get_user_input

  # Проверяем введенную букву специальным методом check_result, которому тоже для
  # работы нужно знать все о состоянии игры: что ввел пользователь, какие буквы
  # есть в слове и какие буквы пользователь уже пробовал.
  result = check_result(user_input, letters, good_letters, bad_letters)

  # В зависимости от того, что вернул нам метод check_result, мы принимаем одно
  # из решений:
  if result == -1
    # Если метод вернул -1, значит буква не угадана: увеличиваем счетчик ошибок
    errors += 1
  elsif result == 1
    # Если результат равен 1, значит пользователь угадал всё слово и пора
    # зукругляться — прерываем цикл.
    break
  end
  # Если check_result вернул нам 0, значит игра продолжается, мы ничего не
  # делаем, а просто запускаем тело цикла снова.
end

# выводим напоследок результат игры
print_status(letters, good_letters, bad_letters, errors)